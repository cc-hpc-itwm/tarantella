#!/usr/bin/env python
import argparse
import logging
import os
import shutil
import subprocess
import sys

TNT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
LIB_DIR = os.path.join(TNT_DIR, "lib/tarantella")
PYLIB_DIR = os.path.join(TNT_DIR, "lib/tarantella/python")
sys.path.append(LIB_DIR)
sys.path.append(PYLIB_DIR)

try:
  import runtime
except ModuleNotFoundError as e:
  raise RuntimeError("[CLI] Cannot find Tarantella `runtime` module; \
make sure the `tarantella` script is started from an installed version.") from e

import runtime.file_management as file_man
import runtime.logging_config as logging_config
import runtime.platform_config as platform_config
import runtime.environment_config as env_config
from runtime import logger

def parse_args():
  parser = argparse.ArgumentParser()
  multinode_group = parser.add_argument_group('Multi-node execution')
  multinode_group.add_argument("--hostfile",
                      dest = "hostfile",
                      help="Path to the list of nodes (hostnames) on which to execute the code",
                      default = None)
  multinode_group.add_argument("--n-per-node", "--devices-per-node",
                    help="Number of devices (i.e., either GPUs or CPUs) to be used per node",
                    dest = "npernode",
                    type = int,
                    default = None)
  singlenode_group = parser.add_argument_group('Single-node execution')
  singlenode_group.add_argument("-n",
                    help="Number of processes to start on the local node",
                    dest = "npernode",
                    type = int,
                    default = None)

  parser.add_argument("--no-gpu",
                    help="Disable GPU usage",
                    dest = "use_gpus",
                    action='store_false',
                    default = True)
  parser.add_argument("--output-all-devices",
                    help="Enable output from all devices (e.g., training info)",
                    dest = "output_all",
                    action='store_true',
                    default = False)
  parser.add_argument("--log-all-devices",
                    help="Enable logging on all devices",
                    dest = "log_all",
                    action='store_true',
                    default = False)
  log_levels = ('DEBUG', 'INFO', 'WARNING', 'ERROR')
  parser.add_argument('--log-level', default='WARNING', choices=log_levels)
  parser.add_argument('script', nargs='+')
  args = parser.parse_args()
  return args

def generate_run_error_string(e, executed_script_path = None):
  error_string = ""
  if not e.stdout is None:
    error_string += "============= STDOUT =============\n{}\n".format(e.stdout)
  if not e.stderr is None:
    error_string += "============= STDERR =============\n{}\n".format(e.stderr)
  if not executed_script_path is None:
    error_string += "\n{}\nExecuted script:\n".format("="*80)
    with open(executed_script_path, 'r') as f:
      error_string += "============= {} =============\n{}\n".format(executed_script_path,
                                                                    "".join(f.readlines()))
  error_string += "\n{}".format("="*80)
  error_string += "\nCommand:\n\t{}\n".format(" ".join(e.cmd))
  error_string += "[CLI] Execution failed with status {}\n".format(e.returncode)
  return error_string


class Tarantella:
  def __init__(self, hostlist, num_gpus_per_node, num_cpus_per_node,
               command_list, log_all, output_all):
    self.log_level = logging.getLevelName(logger.level)
    self.log_all = log_all
    self.output_all = output_all

    self.hostlist = hostlist
    self.command_list = command_list

    self.npernode = num_gpus_per_node
    if self.npernode == 0:
      self.npernode = num_cpus_per_node

    self.nranks = len(hostlist) * self.npernode
    self.hostfile = file_man.HostFile(self.hostlist, self.npernode)
    self.executable_script = self.generate_executable_script()

  def generate_executable_script(self):
    # create execution script
    header = "#!/bin/bash"

    environment = env_config.gen_exports_from_dict(env_config.collect_environment_variables()) + \
                  env_config.gen_exports_from_dict(env_config.collect_tensorflow_variables()) + \
                  env_config.gen_exports_from_dict(env_config.collect_tarantella_variables()) + \
                  env_config.gen_exports_from_dict(env_config.get_logging_variables(self.log_level,
                                                                                    self.log_all,
                                                                                    self.output_all))

    command = "python %s" % (' '.join(self.command_list))
    return file_man.GPIScriptFile(header, environment, command, dir = os.getcwd())

  def run(self):
    path_to_gpi = shutil.which("gaspi_run")
    if path_to_gpi is None:
      sys.exit("[CLI] Cannot execute `gaspi_run`; make sure it is added to the current `PATH`.")

    with self.hostfile, self.executable_script:
      command_list = ["gaspi_run", "-n", str(self.nranks),
                      "-m", self.hostfile.name,
                      self.executable_script.filename]
      try:
        result = subprocess.run(command_list,
                    check = True,
                    cwd = os.getcwd(),
                    stdout = None, stderr = None,)
      except subprocess.CalledProcessError as e:
        sys.exit(generate_run_error_string(e, self.executable_script.filename))

if __name__ == "__main__":
  args = parse_args()
  logging_config.setup_logging(logger, args.log_level)

  nodes_list = platform_config.generate_nodes_list(args.hostfile)
  num_gpus, num_cpus = platform_config.generate_num_devices_per_node(npernode = args.npernode,
                                                                     use_gpus = args.use_gpus)
  env_config.update_environment_paths(LIB_DIR)

  tarantella = Tarantella(nodes_list, num_gpus, num_cpus, args.script,
                          args.log_all, args.output_all)
  tarantella.run()